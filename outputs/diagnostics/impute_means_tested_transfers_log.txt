-------------------------------------------------------------------------------------------------------------------
      name:  <unnamed>
       log:  C:\data\sandboxes\means_tested_transfer_imputations\source_code\..\outputs\diagnostics\impute_means_te
> sted_transfers_log.txt
  log type:  text
 opened on:  26 Oct 2021, 13:53:20

. 
. insheet using "$input_path\CBO_targets_means_tested_transfers.csv", clear
(9 vars, 41 obs)

. save "$input_path\CBO_targets_means_tested_transfers.dta", replace
file ..\inputs\CBO_targets_means_tested_transfers.dta saved

. 
. // The imputation method is conducted separately for eight subgroups across the
. // three means-tested transfer programs.
. #delimit ;
delimiter now ;
. local subgroups "mcaid_adult
>                  mcaid_child
>                  mcaid_senior
>                  mcaid_disabled
>                  snap_allhhd
>                  ssi_adult
>                  ssi_child
>                  ssi_senior";

. #delimit cr
delimiter now cr
. 
. foreach year of numlist $cps_start_year / $cps_end_year {
  2. 
.   insheet using "$input_path\CBO_probabilities_means_tested_transfers_`year'.csv", clear
  3. 
.   qui merge m:1 year using "$input_path\CBO_targets_means_tested_transfers.dta"
  4.   drop if _merge != 3
  5.   drop _merge
  6. 
.   // Loop through the three means-tested programs to create the variables
.   // for the imputed recipiency status and imputed benefit values. The algorithm
.   // will fill in these variables as it moves through the subgroups.
.   foreach program in mcaid snap ssi housing_assist {
  7. 
.     gen `program'_impute = 0
  8.     label var `program'_impute "Post-imputation recipient of `program'"
  9. 
.     gen `program'_impute_val = 0
 10.     label var `program'_impute_val "Post-imputation value of `program' benefits"
 11. 
.   }
 12. 
. 
.   /*
>   ****************************************************************************************
>   ** LOOP THROUGH SUBGROUPS TO ASSIGN TRANSFER RECEIPT
>   ****************************************************************************************
>   */
. 
.   foreach group in `subgroups' {
 13.     do assign_transfer_receipt.do "`group'"
 14.   }
 15. 
.   // For housing subsidies, CBO does not impute additional recipients beyond the units
.   // that report receipt in the CPS. However, the agency does estimate benefit values
.   // for reporting units. Those values are included in the accompanying datasets.
.   replace housing_assist_impute = housing_assist_report
 16.   replace housing_assist_impute_val = housing_assist_potential_val
 17. 
.   drop *potential* *target* *child *adult *senior *allhhd *disabled *prob *rand *report
 18.   save "$output_data_path\CBO_imputed_means_tested_transfers_`year'.dta", replace
 19. 
. } // End of foreach year... loop
(27 vars, 181,488 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(83,153 missing values generated)
(1,376 real changes made)
(83,153 missing values generated)
(530 real changes made)
(83,153 missing values generated)
(312 real changes made)
(83,153 missing values generated)
(220 real changes made)
(83,153 missing values generated)
(196 real changes made)
(83,153 missing values generated)
(189 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,900 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,900 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(123,862 missing values generated)
(1,577 real changes made)
(123,862 missing values generated)
(1,611 real changes made)
(123,862 missing values generated)
(1,620 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,248 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,248 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(162,374 missing values generated)
(1,393 real changes made)
(162,374 missing values generated)
(1,099 real changes made)
(162,374 missing values generated)
(904 real changes made)
(162,374 missing values generated)
(735 real changes made)
(162,374 missing values generated)
(666 real changes made)
(162,374 missing values generated)
(646 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,168 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,168 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(175,075 missing values generated)
(451 real changes made)
(175,075 missing values generated)
(442 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,976 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,976 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(116,250 missing values generated)
(2,425 real changes made)
(116,250 missing values generated)
(2,410 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,411 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,411 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(73,488 missing values generated)
(513 real changes made)
(73,488 missing values generated)
(555 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,512 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,512 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(127,114 missing values generated)
(195 real changes made)
(127,114 missing values generated)
(168 real changes made)
(127,114 missing values generated)
(118 real changes made)
(127,114 missing values generated)
(84 real changes made)
(127,114 missing values generated)
(70 real changes made)
(127,114 missing values generated)
(57 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(149 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(149 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(162,374 missing values generated)
(544 real changes made)
(162,374 missing values generated)
(457 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,998 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,998 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(118,319 real changes made, 116,250 to missing)
(181,488 real changes made, 179,419 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1980.dta saved
(27 vars, 181,358 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(82,055 missing values generated)
(1,473 real changes made)
(82,055 missing values generated)
(699 real changes made)
(82,055 missing values generated)
(529 real changes made)
(82,055 missing values generated)
(439 real changes made)
(82,055 missing values generated)
(376 real changes made)
(82,055 missing values generated)
(353 real changes made)
(82,055 missing values generated)
(343 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,154 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,154 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(124,583 missing values generated)
(1,639 real changes made)
(124,583 missing values generated)
(1,166 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,070 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,070 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(162,149 missing values generated)
(1,099 real changes made)
(162,149 missing values generated)
(829 real changes made)
(162,149 missing values generated)
(672 real changes made)
(162,149 missing values generated)
(521 real changes made)
(162,149 missing values generated)
(460 real changes made)
(162,149 missing values generated)
(445 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,003 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,003 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(175,287 missing values generated)
(462 real changes made)
(175,287 missing values generated)
(600 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,133 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,133 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,627 missing values generated)
(2,661 real changes made)
(115,627 missing values generated)
(2,903 real changes made)
(115,627 missing values generated)
(2,921 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,529 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,529 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(72,762 missing values generated)
(509 real changes made)
(72,762 missing values generated)
(541 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,534 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,534 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(127,805 missing values generated)
(227 real changes made)
(127,805 missing values generated)
(204 real changes made)
(127,805 missing values generated)
(159 real changes made)
(127,805 missing values generated)
(108 real changes made)
(127,805 missing values generated)
(88 real changes made)
(127,805 missing values generated)
(79 real changes made)
(127,805 missing values generated)
(68 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(173 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(173 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(162,149 missing values generated)
(484 real changes made)
(162,149 missing values generated)
(405 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,930 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,930 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(117,814 real changes made, 115,627 to missing)
(181,358 real changes made, 179,171 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1981.dta saved
(27 vars, 162,703 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(73,311 missing values generated)
(1,299 real changes made)
(73,311 missing values generated)
(536 real changes made)
(73,311 missing values generated)
(325 real changes made)
(73,311 missing values generated)
(256 real changes made)
(73,311 missing values generated)
(235 real changes made)
(73,311 missing values generated)
(215 real changes made)
(73,311 missing values generated)
(202 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,881 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,881 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,696 missing values generated)
(1,285 real changes made)
(112,696 missing values generated)
(908 real changes made)
(112,696 missing values generated)
(883 real changes made)
(112,696 missing values generated)
(874 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,177 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,177 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(145,097 missing values generated)
(1,029 real changes made)
(145,097 missing values generated)
(831 real changes made)
(145,097 missing values generated)
(726 real changes made)
(145,097 missing values generated)
(632 real changes made)
(145,097 missing values generated)
(585 real changes made)
(145,097 missing values generated)
(551 real changes made)
(145,097 missing values generated)
(538 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,693 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,693 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(157,005 missing values generated)
(378 real changes made)
(157,005 missing values generated)
(484 real changes made)
(157,005 missing values generated)
(465 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,892 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,892 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(103,427 missing values generated)
(2,238 real changes made)
(103,427 missing values generated)
(2,873 real changes made)
(103,427 missing values generated)
(2,917 real changes made)
(103,427 missing values generated)
(2,897 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,029 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,029 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(64,849 missing values generated)
(480 real changes made)
(64,849 missing values generated)
(418 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,374 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,374 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,460 missing values generated)
(183 real changes made)
(115,460 missing values generated)
(137 real changes made)
(115,460 missing values generated)
(85 real changes made)
(115,460 missing values generated)
(50 real changes made)
(115,460 missing values generated)
(28 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(161 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(161 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(145,097 missing values generated)
(428 real changes made)
(145,097 missing values generated)
(390 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,670 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,670 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(105,458 real changes made, 103,427 to missing)
(162,703 real changes made, 160,672 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1982.dta saved
(27 vars, 162,635 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(72,410 missing values generated)
(1,180 real changes made)
(72,410 missing values generated)
(170 real changes made)
(72,410 missing values generated)
(32 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,901 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,901 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(113,403 missing values generated)
(1,163 real changes made)
(113,403 missing values generated)
(770 real changes made)
(113,403 missing values generated)
(791 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,967 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,967 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(144,760 missing values generated)
(955 real changes made)
(144,760 missing values generated)
(738 real changes made)
(144,760 missing values generated)
(623 real changes made)
(144,760 missing values generated)
(525 real changes made)
(144,760 missing values generated)
(452 real changes made)
(144,760 missing values generated)
(441 real changes made)
(144,760 missing values generated)
(431 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,609 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,609 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(157,332 missing values generated)
(336 real changes made)
(157,332 missing values generated)
(515 real changes made)
(157,332 missing values generated)
(532 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,806 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,806 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(103,424 missing values generated)
(2,312 real changes made)
(103,424 missing values generated)
(2,392 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,573 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,573 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(64,433 missing values generated)
(449 real changes made)
(64,433 missing values generated)
(470 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,312 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,312 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(116,077 missing values generated)
(194 real changes made)
(116,077 missing values generated)
(154 real changes made)
(116,077 missing values generated)
(93 real changes made)
(116,077 missing values generated)
(71 real changes made)
(116,077 missing values generated)
(59 real changes made)
(116,077 missing values generated)
(52 real changes made)
(116,077 missing values generated)
(49 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(156 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(156 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(144,760 missing values generated)
(388 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,569 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,569 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(105,620 real changes made, 103,424 to missing)
(162,635 real changes made, 160,439 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1983.dta saved
(27 vars, 161,167 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(71,102 missing values generated)
(1,128 real changes made)
(71,102 missing values generated)
(372 real changes made)
(71,102 missing values generated)
(208 real changes made)
(71,102 missing values generated)
(150 real changes made)
(71,102 missing values generated)
(139 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,870 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,870 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,847 missing values generated)
(1,156 real changes made)
(112,847 missing values generated)
(675 real changes made)
(112,847 missing values generated)
(659 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,746 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,746 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,392 missing values generated)
(934 real changes made)
(143,392 missing values generated)
(750 real changes made)
(143,392 missing values generated)
(689 real changes made)
(143,392 missing values generated)
(609 real changes made)
(143,392 missing values generated)
(552 real changes made)
(143,392 missing values generated)
(511 real changes made)
(143,392 missing values generated)
(502 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,540 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,540 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(156,160 missing values generated)
(309 real changes made)
(156,160 missing values generated)
(439 real changes made)
(156,160 missing values generated)
(475 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,726 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,726 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(101,996 missing values generated)
(2,296 real changes made)
(101,996 missing values generated)
(2,055 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,079 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,079 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(63,543 missing values generated)
(460 real changes made)
(63,543 missing values generated)
(413 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,285 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,285 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,399 missing values generated)
(181 real changes made)
(115,399 missing values generated)
(155 real changes made)
(115,399 missing values generated)
(91 real changes made)
(115,399 missing values generated)
(47 real changes made)
(115,399 missing values generated)
(34 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(152 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(152 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,392 missing values generated)
(398 real changes made)
(143,392 missing values generated)
(302 real changes made)
(143,392 missing values generated)
(287 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,507 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,507 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(104,226 real changes made, 101,996 to missing)
(161,167 real changes made, 158,937 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1984.dta saved
(27 vars, 161,362 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(70,929 missing values generated)
(1,096 real changes made)
(70,929 missing values generated)
(450 real changes made)
(70,929 missing values generated)
(293 real changes made)
(70,929 missing values generated)
(240 real changes made)
(70,929 missing values generated)
(222 real changes made)
(70,929 missing values generated)
(214 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,840 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,840 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(113,663 missing values generated)
(1,072 real changes made)
(113,663 missing values generated)
(937 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,972 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,972 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,166 missing values generated)
(842 real changes made)
(143,166 missing values generated)
(726 real changes made)
(143,166 missing values generated)
(686 real changes made)
(143,166 missing values generated)
(644 real changes made)
(143,166 missing values generated)
(601 real changes made)
(143,166 missing values generated)
(584 real changes made)
(143,166 missing values generated)
(563 real changes made)
(143,166 missing values generated)
(550 real changes made)
(143,166 missing values generated)
(545 real changes made)
(143,166 missing values generated)
(539 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,413 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,413 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(156,328 missing values generated)
(322 real changes made)
(156,328 missing values generated)
(438 real changes made)
(156,328 missing values generated)
(463 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,796 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,796 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(101,563 missing values generated)
(2,166 real changes made)
(101,563 missing values generated)
(1,765 real changes made)
(101,563 missing values generated)
(1,812 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,724 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,724 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(63,489 missing values generated)
(453 real changes made)
(63,489 missing values generated)
(437 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,360 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,360 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(116,069 missing values generated)
(196 real changes made)
(116,069 missing values generated)
(157 real changes made)
(116,069 missing values generated)
(72 real changes made)
(116,069 missing values generated)
(47 real changes made)
(116,069 missing values generated)
(39 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(163 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(163 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,166 missing values generated)
(397 real changes made)
(143,166 missing values generated)
(328 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,530 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,530 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(104,031 real changes made, 101,563 to missing)
(161,362 real changes made, 158,894 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1985.dta saved
(27 vars, 157,605 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(69,571 missing values generated)
(963 real changes made)
(69,571 missing values generated)
(216 real changes made)
(69,571 missing values generated)
(82 real changes made)
(69,571 missing values generated)
(45 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,768 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,768 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(111,369 missing values generated)
(966 real changes made)
(111,369 missing values generated)
(872 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,698 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,698 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(139,313 missing values generated)
(796 real changes made)
(139,313 missing values generated)
(666 real changes made)
(139,313 missing values generated)
(647 real changes made)
(139,313 missing values generated)
(620 real changes made)
(139,313 missing values generated)
(599 real changes made)
(139,313 missing values generated)
(587 real changes made)
(139,313 missing values generated)
(575 real changes made)
(139,313 missing values generated)
(567 real changes made)
(139,313 missing values generated)
(560 real changes made)
(139,313 missing values generated)
(556 real changes made)
(139,313 missing values generated)
(547 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,278 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,278 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(152,562 missing values generated)
(317 real changes made)
(152,562 missing values generated)
(499 real changes made)
(152,562 missing values generated)
(535 real changes made)
(152,562 missing values generated)
(542 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,785 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,785 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(98,691 missing values generated)
(2,007 real changes made)
(98,691 missing values generated)
(1,704 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,253 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,253 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(62,279 missing values generated)
(481 real changes made)
(62,279 missing values generated)
(465 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,385 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,385 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(113,618 missing values generated)
(174 real changes made)
(113,618 missing values generated)
(133 real changes made)
(113,618 missing values generated)
(62 real changes made)
(113,618 missing values generated)
(28 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(157 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(157 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(139,313 missing values generated)
(358 real changes made)
(139,313 missing values generated)
(331 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,458 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,458 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(101,294 real changes made, 98,691 to missing)
(157,605 real changes made, 155,002 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1986.dta saved
(27 vars, 155,407 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(68,514 missing values generated)
(1,036 real changes made)
(68,514 missing values generated)
(268 real changes made)
(68,514 missing values generated)
(118 real changes made)
(68,514 missing values generated)
(102 real changes made)
(68,514 missing values generated)
(90 real changes made)
(68,514 missing values generated)
(81 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,726 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,726 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(109,951 missing values generated)
(1,126 real changes made)
(109,951 missing values generated)
(868 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,727 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,727 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(137,301 missing values generated)
(874 real changes made)
(137,301 missing values generated)
(699 real changes made)
(137,301 missing values generated)
(629 real changes made)
(137,301 missing values generated)
(551 real changes made)
(137,301 missing values generated)
(500 real changes made)
(137,301 missing values generated)
(473 real changes made)
(137,301 missing values generated)
(456 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,349 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,349 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(150,455 missing values generated)
(325 real changes made)
(150,455 missing values generated)
(492 real changes made)
(150,455 missing values generated)
(530 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,832 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,832 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(97,149 missing values generated)
(1,920 real changes made)
(97,149 missing values generated)
(1,651 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,033 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,033 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(61,264 missing values generated)
(465 real changes made)
(61,264 missing values generated)
(454 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,415 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,415 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,249 missing values generated)
(195 real changes made)
(112,249 missing values generated)
(164 real changes made)
(112,249 missing values generated)
(87 real changes made)
(112,249 missing values generated)
(64 real changes made)
(112,249 missing values generated)
(47 real changes made)
(112,249 missing values generated)
(40 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(163 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(163 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(137,301 missing values generated)
(366 real changes made)
(137,301 missing values generated)
(419 real changes made)
(137,301 missing values generated)
(443 real changes made)
(137,301 missing values generated)
(430 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,468 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,468 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(99,744 real changes made, 97,149 to missing)
(155,407 real changes made, 152,812 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1987.dta saved
(27 vars, 155,980 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(70,391 missing values generated)
(899 real changes made)
(70,391 missing values generated)
(435 real changes made)
(70,391 missing values generated)
(442 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,703 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,703 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(110,771 missing values generated)
(1,133 real changes made)
(110,771 missing values generated)
(919 real changes made)
(110,771 missing values generated)
(927 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,694 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,694 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(137,370 missing values generated)
(658 real changes made)
(137,370 missing values generated)
(469 real changes made)
(137,370 missing values generated)
(287 real changes made)
(137,370 missing values generated)
(190 real changes made)
(137,370 missing values generated)
(183 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,351 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,351 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(149,408 missing values generated)
(356 real changes made)
(149,408 missing values generated)
(396 real changes made)
(149,408 missing values generated)
(405 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,945 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,945 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(97,005 missing values generated)
(1,717 real changes made)
(97,005 missing values generated)
(1,531 real changes made)
(97,005 missing values generated)
(1,544 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,739 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,739 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(61,642 missing values generated)
(440 real changes made)
(61,642 missing values generated)
(450 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,495 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,495 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,948 missing values generated)
(179 real changes made)
(112,948 missing values generated)
(122 real changes made)
(112,948 missing values generated)
(55 real changes made)
(112,948 missing values generated)
(35 real changes made)
(112,948 missing values generated)
(29 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(165 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(165 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(137,370 missing values generated)
(318 real changes made)
(137,370 missing values generated)
(426 real changes made)
(137,370 missing values generated)
(456 real changes made)
(137,370 missing values generated)
(466 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,433 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,433 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(99,685 real changes made, 97,005 to missing)
(155,980 real changes made, 153,300 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1988.dta saved
(27 vars, 144,687 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(65,378 missing values generated)
(879 real changes made)
(65,378 missing values generated)
(269 real changes made)
(65,378 missing values generated)
(246 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,260 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,260 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(103,151 missing values generated)
(1,013 real changes made)
(103,151 missing values generated)
(732 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,951 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,951 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(126,947 missing values generated)
(611 real changes made)
(126,947 missing values generated)
(454 real changes made)
(126,947 missing values generated)
(362 real changes made)
(126,947 missing values generated)
(318 real changes made)
(126,947 missing values generated)
(273 real changes made)
(126,947 missing values generated)
(259 real changes made)
(126,947 missing values generated)
(255 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,175 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,175 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(138,585 missing values generated)
(345 real changes made)
(138,585 missing values generated)
(431 real changes made)
(138,585 missing values generated)
(441 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,816 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,816 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(89,352 missing values generated)
(1,624 real changes made)
(89,352 missing values generated)
(1,392 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,204 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,204 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(57,222 missing values generated)
(417 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,422 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,422 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(105,205 missing values generated)
(169 real changes made)
(105,205 missing values generated)
(100 real changes made)
(105,205 missing values generated)
(43 real changes made)
(105,205 missing values generated)
(31 real changes made)
(105,205 missing values generated)
(28 real changes made)
(105,205 missing values generated)
(23 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(162 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(162 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(126,947 missing values generated)
(295 real changes made)
(126,947 missing values generated)
(402 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,277 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,277 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(91,821 real changes made, 89,352 to missing)
(144,687 real changes made, 142,218 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1989.dta saved
(27 vars, 158,079 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(71,067 missing values generated)
(1,137 real changes made)
(71,067 missing values generated)
(437 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,898 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,898 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,623 missing values generated)
(1,348 real changes made)
(112,623 missing values generated)
(1,220 real changes made)
(112,623 missing values generated)
(1,205 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,037 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,037 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(139,177 missing values generated)
(678 real changes made)
(139,177 missing values generated)
(513 real changes made)
(139,177 missing values generated)
(443 real changes made)
(139,177 missing values generated)
(381 real changes made)
(139,177 missing values generated)
(344 real changes made)
(139,177 missing values generated)
(322 real changes made)
(139,177 missing values generated)
(313 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,302 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,302 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(151,370 missing values generated)
(385 real changes made)
(151,370 missing values generated)
(482 real changes made)
(151,370 missing values generated)
(512 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,141 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,141 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(98,138 missing values generated)
(1,784 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,971 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,971 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(62,183 missing values generated)
(502 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,656 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,656 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(114,798 missing values generated)
(197 real changes made)
(114,798 missing values generated)
(153 real changes made)
(114,798 missing values generated)
(63 real changes made)
(114,798 missing values generated)
(36 real changes made)
(114,798 missing values generated)
(32 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(173 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(173 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(139,177 missing values generated)
(333 real changes made)
(139,177 missing values generated)
(408 real changes made)
(139,177 missing values generated)
(386 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,400 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,400 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(100,849 real changes made, 98,138 to missing)
(158,079 real changes made, 155,368 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1990.dta saved
(27 vars, 158,477 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(71,484 missing values generated)
(1,309 real changes made)
(71,484 missing values generated)
(307 real changes made)
(71,484 missing values generated)
(287 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,233 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,233 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,788 missing values generated)
(1,695 real changes made)
(112,788 missing values generated)
(980 real changes made)
(112,788 missing values generated)
(966 real changes made)
(112,788 missing values generated)
(959 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,855 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,855 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(139,434 missing values generated)
(681 real changes made)
(139,434 missing values generated)
(497 real changes made)
(139,434 missing values generated)
(382 real changes made)
(139,434 missing values generated)
(292 real changes made)
(139,434 missing values generated)
(259 real changes made)
(139,434 missing values generated)
(240 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,404 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,404 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(151,725 missing values generated)
(442 real changes made)
(151,725 missing values generated)
(460 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,332 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,332 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(98,548 missing values generated)
(1,836 real changes made)
(98,548 missing values generated)
(1,846 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,448 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,448 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(62,805 missing values generated)
(558 real changes made)
(62,805 missing values generated)
(526 real changes made)
(62,805 missing values generated)
(518 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,774 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,774 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(224 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(224 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(139,434 missing values generated)
(359 real changes made)
(139,434 missing values generated)
(466 real changes made)
(139,434 missing values generated)
(471 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,457 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,457 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(101,441 real changes made, 98,548 to missing)
(158,477 real changes made, 155,584 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1991.dta saved
(27 vars, 155,783 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(70,360 missing values generated)
(1,357 real changes made)
(70,360 missing values generated)
(217 real changes made)
(70,360 missing values generated)
(254 real changes made)
(70,360 missing values generated)
(243 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,536 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,536 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(111,206 missing values generated)
(1,691 real changes made)
(111,206 missing values generated)
(1,443 real changes made)
(111,206 missing values generated)
(1,431 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,791 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,791 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(136,829 missing values generated)
(739 real changes made)
(136,829 missing values generated)
(572 real changes made)
(136,829 missing values generated)
(474 real changes made)
(136,829 missing values generated)
(399 real changes made)
(136,829 missing values generated)
(360 real changes made)
(136,829 missing values generated)
(344 real changes made)
(136,829 missing values generated)
(337 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,477 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,477 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(148,954 missing values generated)
(457 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,390 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,390 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(96,568 missing values generated)
(1,946 real changes made)
(96,568 missing values generated)
(2,357 real changes made)
(96,568 missing values generated)
(2,312 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,288 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,288 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(61,651 missing values generated)
(541 real changes made)
(61,651 missing values generated)
(501 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,799 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,799 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(113,086 missing values generated)
(215 real changes made)
(113,086 missing values generated)
(12 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(248 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(248 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(136,829 missing values generated)
(356 real changes made)
(136,829 missing values generated)
(392 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,451 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,451 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(99,473 real changes made, 96,568 to missing)
(155,783 real changes made, 152,878 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1992.dta saved
(27 vars, 155,197 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(70,756 missing values generated)
(1,482 real changes made)
(70,756 missing values generated)
(265 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,578 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,578 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(110,494 missing values generated)
(1,904 real changes made)
(110,494 missing values generated)
(2,421 real changes made)
(110,494 missing values generated)
(2,476 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,038 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,038 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(136,123 missing values generated)
(748 real changes made)
(136,123 missing values generated)
(427 real changes made)
(136,123 missing values generated)
(290 real changes made)
(136,123 missing values generated)
(214 real changes made)
(136,123 missing values generated)
(198 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,586 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,586 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(148,218 missing values generated)
(553 real changes made)
(148,218 missing values generated)
(538 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,673 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,673 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(96,227 missing values generated)
(2,100 real changes made)
(96,227 missing values generated)
(2,726 real changes made)
(96,227 missing values generated)
(2,739 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,003 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,003 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(61,975 missing values generated)
(596 real changes made)
(61,975 missing values generated)
(642 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,023 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,023 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,296 missing values generated)
(293 real changes made)
(112,296 missing values generated)
(76 real changes made)
(112,296 missing values generated)
(61 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(368 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(368 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(136,123 missing values generated)
(400 real changes made)
(136,123 missing values generated)
(390 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,426 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,426 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(99,056 real changes made, 96,227 to missing)
(155,197 real changes made, 152,368 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1993.dta saved
(27 vars, 150,943 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(69,666 missing values generated)
(1,553 real changes made)
(69,666 missing values generated)
(91 real changes made)
(69,666 missing values generated)
(101 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,614 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,614 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(106,887 missing values generated)
(2,358 real changes made)
(106,887 missing values generated)
(1,607 real changes made)
(106,887 missing values generated)
(1,618 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,976 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,976 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,379 missing values generated)
(704 real changes made)
(132,379 missing values generated)
(36 real changes made)
(132,379 missing values generated)
(13 real changes made)
(132,379 missing values generated)
(36 real changes made)
(132,379 missing values generated)
(13 real changes made)
(132,379 missing values generated)
(36 real changes made)
(132,379 missing values generated)
(13 real changes made)
(132,379 missing values generated)
(38 real changes made)
(132,379 missing values generated)
(10 real changes made)
(132,379 missing values generated)
(40 real changes made)
(132,379 missing values generated)
(10 real changes made)
(132,379 missing values generated)
(34 real changes made)
(132,379 missing values generated)
(15 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,635 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,635 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,897 missing values generated)
(502 real changes made)
(143,897 missing values generated)
(627 real changes made)
(143,897 missing values generated)
(611 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,801 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,801 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(93,864 missing values generated)
(2,012 real changes made)
(93,864 missing values generated)
(2,527 real changes made)
(93,864 missing values generated)
(2,623 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,051 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,051 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(60,901 missing values generated)
(646 real changes made)
(60,901 missing values generated)
(610 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,080 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,080 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(108,606 missing values generated)
(362 real changes made)
(108,606 missing values generated)
(59 real changes made)
(108,606 missing values generated)
(66 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(465 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(465 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,379 missing values generated)
(359 real changes made)
(132,379 missing values generated)
(515 real changes made)
(132,379 missing values generated)
(535 real changes made)
(132,379 missing values generated)
(538 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,450 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,450 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(97,012 real changes made, 93,864 to missing)
(150,943 real changes made, 147,795 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1994.dta saved
(27 vars, 149,642 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(68,766 missing values generated)
(2,004 real changes made)
(68,766 missing values generated)
(385 real changes made)
(68,766 missing values generated)
(65 real changes made)
(68,766 missing values generated)
(75 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,595 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,595 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(106,050 missing values generated)
(3,159 real changes made)
(106,050 missing values generated)
(465 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,226 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,226 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(131,455 missing values generated)
(852 real changes made)
(131,455 missing values generated)
(187 real changes made)
(131,455 missing values generated)
(24 real changes made)
(131,455 missing values generated)
(133 real changes made)
(131,455 missing values generated)
(30 real changes made)
(131,455 missing values generated)
(110 real changes made)
(131,455 missing values generated)
(41 real changes made)
(131,455 missing values generated)
(88 real changes made)
(131,455 missing values generated)
(45 real changes made)
(131,455 missing values generated)
(76 real changes made)
(131,455 missing values generated)
(54 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,672 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,672 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(142,655 missing values generated)
(524 real changes made)
(142,655 missing values generated)
(796 real changes made)
(142,655 missing values generated)
(846 real changes made)
(142,655 missing values generated)
(853 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,037 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,037 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(92,701 missing values generated)
(2,011 real changes made)
(92,701 missing values generated)
(2,542 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,686 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,686 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(59,934 missing values generated)
(638 real changes made)
(59,934 missing values generated)
(724 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,181 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,181 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(107,895 missing values generated)
(314 real changes made)
(107,895 missing values generated)
(190 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(518 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(518 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(131,455 missing values generated)
(321 real changes made)
(131,455 missing values generated)
(553 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,407 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,407 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(95,713 real changes made, 92,701 to missing)
(149,642 real changes made, 146,630 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1995.dta saved
(27 vars, 130,476 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(60,163 missing values generated)
(1,793 real changes made)
(60,163 missing values generated)
(671 real changes made)
(60,163 missing values generated)
(682 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,201 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,201 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(92,203 missing values generated)
(2,824 real changes made)
(92,203 missing values generated)
(1,518 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,554 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,554 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(114,734 missing values generated)
(863 real changes made)
(114,734 missing values generated)
(275 real changes made)
(114,734 missing values generated)
(297 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,599 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,599 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(124,328 missing values generated)
(646 real changes made)
(124,328 missing values generated)
(945 real changes made)
(124,328 missing values generated)
(1,033 real changes made)
(124,328 missing values generated)
(1,062 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,918 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,918 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(80,794 missing values generated)
(1,851 real changes made)
(80,794 missing values generated)
(2,211 real changes made)
(80,794 missing values generated)
(2,249 real changes made)
(80,794 missing values generated)
(2,252 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,623 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,623 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(52,433 missing values generated)
(589 real changes made)
(52,433 missing values generated)
(632 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,961 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,961 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(93,785 missing values generated)
(312 real changes made)
(93,785 missing values generated)
(171 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(493 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(493 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(114,734 missing values generated)
(257 real changes made)
(114,734 missing values generated)
(474 real changes made)
(114,734 missing values generated)
(521 real changes made)
(114,734 missing values generated)
(540 real changes made)
(114,734 missing values generated)
(546 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,225 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,225 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(83,416 real changes made, 80,794 to missing)
(130,476 real changes made, 127,854 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1996.dta saved
(27 vars, 131,854 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(60,621 missing values generated)
(1,883 real changes made)
(60,621 missing values generated)
(444 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,997 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,997 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(93,537 missing values generated)
(2,931 real changes made)
(93,537 missing values generated)
(1,509 real changes made)
(93,537 missing values generated)
(1,521 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,226 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,226 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,899 missing values generated)
(927 real changes made)
(115,899 missing values generated)
(233 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,719 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,719 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(125,505 missing values generated)
(708 real changes made)
(125,505 missing values generated)
(1,011 real changes made)
(125,505 missing values generated)
(1,110 real changes made)
(125,505 missing values generated)
(1,133 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,124 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,124 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(81,543 missing values generated)
(1,745 real changes made)
(81,543 missing values generated)
(2,105 real changes made)
(81,543 missing values generated)
(2,142 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,384 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,384 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(52,630 missing values generated)
(623 real changes made)
(52,630 missing values generated)
(598 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,053 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,053 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(95,179 missing values generated)
(328 real changes made)
(95,179 missing values generated)
(150 real changes made)
(95,179 missing values generated)
(174 real changes made)
(95,179 missing values generated)
(164 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(500 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(500 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,899 missing values generated)
(295 real changes made)
(115,899 missing values generated)
(425 real changes made)
(115,899 missing values generated)
(454 real changes made)
(115,899 missing values generated)
(467 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,220 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,220 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(84,216 real changes made, 81,543 to missing)
(131,854 real changes made, 129,181 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1997.dta saved
(27 vars, 131,599 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(60,140 missing values generated)
(1,458 real changes made)
(60,140 missing values generated)
(1,016 real changes made)
(60,140 missing values generated)
(1,020 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,832 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,832 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(93,278 missing values generated)
(2,911 real changes made)
(93,278 missing values generated)
(2,002 real changes made)
(93,278 missing values generated)
(2,040 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,093 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,093 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,939 missing values generated)
(799 real changes made)
(115,939 missing values generated)
(263 real changes made)
(115,939 missing values generated)
(253 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,546 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,546 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(125,440 missing values generated)
(660 real changes made)
(125,440 missing values generated)
(1,036 real changes made)
(125,440 missing values generated)
(1,144 real changes made)
(125,440 missing values generated)
(1,165 real changes made)
(125,440 missing values generated)
(1,171 real changes made)
(125,440 missing values generated)
(1,172 real changes made)
(125,440 missing values generated)
(1,177 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,104 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,104 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(81,251 missing values generated)
(1,586 real changes made)
(81,251 missing values generated)
(1,820 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,520 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,520 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(52,283 missing values generated)
(600 real changes made)
(52,283 missing values generated)
(557 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,016 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,016 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(94,976 missing values generated)
(306 real changes made)
(94,976 missing values generated)
(149 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(452 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(452 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,939 missing values generated)
(277 real changes made)
(115,939 missing values generated)
(455 real changes made)
(115,939 missing values generated)
(478 real changes made)
(115,939 missing values generated)
(489 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,165 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,165 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(83,722 real changes made, 81,251 to missing)
(131,599 real changes made, 129,128 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1998.dta saved
(27 vars, 132,309 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(60,087 missing values generated)
(1,411 real changes made)
(60,087 missing values generated)
(1,653 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,119 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,119 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(94,057 missing values generated)
(2,953 real changes made)
(94,057 missing values generated)
(4,097 real changes made)
(94,057 missing values generated)
(4,222 real changes made)
(94,057 missing values generated)
(4,240 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,834 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,834 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(116,481 missing values generated)
(773 real changes made)
(116,481 missing values generated)
(254 real changes made)
(116,481 missing values generated)
(233 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,521 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,521 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(126,302 missing values generated)
(630 real changes made)
(126,302 missing values generated)
(1,213 real changes made)
(126,302 missing values generated)
(1,412 real changes made)
(126,302 missing values generated)
(1,487 real changes made)
(126,302 missing values generated)
(1,526 real changes made)
(126,302 missing values generated)
(1,547 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,295 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,295 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(81,528 missing values generated)
(1,462 real changes made)
(81,528 missing values generated)
(1,611 real changes made)
(81,528 missing values generated)
(1,619 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,776 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,776 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(52,346 missing values generated)
(520 real changes made)
(52,346 missing values generated)
(604 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,984 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,984 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(95,791 missing values generated)
(261 real changes made)
(95,791 missing values generated)
(208 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(475 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(475 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(116,481 missing values generated)
(246 real changes made)
(116,481 missing values generated)
(489 real changes made)
(116,481 missing values generated)
(496 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,131 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,131 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(83,985 real changes made, 81,528 to missing)
(132,309 real changes made, 129,852 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_1999.dta saved
(27 vars, 133,710 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(60,288 missing values generated)
(1,536 real changes made)
(60,288 missing values generated)
(1,752 real changes made)
(60,288 missing values generated)
(1,768 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,290 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,290 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(95,502 missing values generated)
(3,454 real changes made)
(95,502 missing values generated)
(4,732 real changes made)
(95,502 missing values generated)
(4,893 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(11,975 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(11,975 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(117,802 missing values generated)
(788 real changes made)
(117,802 missing values generated)
(121 real changes made)
(117,802 missing values generated)
(130 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,442 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,442 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(127,538 missing values generated)
(673 real changes made)
(127,538 missing values generated)
(1,277 real changes made)
(127,538 missing values generated)
(1,457 real changes made)
(127,538 missing values generated)
(1,522 real changes made)
(127,538 missing values generated)
(1,552 real changes made)
(127,538 missing values generated)
(1,564 real changes made)
(127,538 missing values generated)
(1,573 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,364 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,364 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(82,694 missing values generated)
(1,437 real changes made)
(82,694 missing values generated)
(1,646 real changes made)
(82,694 missing values generated)
(1,657 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,593 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,593 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(52,401 missing values generated)
(599 real changes made)
(52,401 missing values generated)
(583 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,979 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,979 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(97,217 missing values generated)
(246 real changes made)
(97,217 missing values generated)
(199 real changes made)
(97,217 missing values generated)
(214 real changes made)
(97,217 missing values generated)
(203 real changes made)
(97,217 missing values generated)
(214 real changes made)
(97,217 missing values generated)
(206 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(457 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(457 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(117,802 missing values generated)
(254 real changes made)
(117,802 missing values generated)
(443 real changes made)
(117,802 missing values generated)
(454 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,081 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,081 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(84,978 real changes made, 82,694 to missing)
(133,710 real changes made, 131,426 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2000.dta saved
(27 vars, 218,269 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(101,173 missing values generated)
(2,666 real changes made)
(101,173 missing values generated)
(3,861 real changes made)
(101,173 missing values generated)
(3,940 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,001 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,001 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(147,078 missing values generated)
(6,529 real changes made)
(147,078 missing values generated)
(10,111 real changes made)
(147,078 missing values generated)
(10,404 real changes made)
(147,078 missing values generated)
(10,448 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(23,075 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(23,075 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(197,638 missing values generated)
(1,069 real changes made)
(197,638 missing values generated)
(12 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,995 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,995 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(208,918 missing values generated)
(1,141 real changes made)
(208,918 missing values generated)
(1,935 real changes made)
(208,918 missing values generated)
(2,228 real changes made)
(208,918 missing values generated)
(2,291 real changes made)
(208,918 missing values generated)
(2,305 real changes made)
(208,918 missing values generated)
(2,310 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,211 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,211 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(140,215 missing values generated)
(2,306 real changes made)
(140,215 missing values generated)
(2,411 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,966 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,966 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(88,714 missing values generated)
(990 real changes made)
(88,714 missing values generated)
(863 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,042 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,042 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(150,186 missing values generated)
(553 real changes made)
(150,186 missing values generated)
(243 real changes made)
(150,186 missing values generated)
(229 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(820 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(820 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(197,638 missing values generated)
(393 real changes made)
(197,638 missing values generated)
(668 real changes made)
(197,638 missing values generated)
(672 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,503 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,503 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(144,017 real changes made, 140,215 to missing)
(218,269 real changes made, 214,467 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2001.dta saved
(27 vars, 217,219 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(100,497 missing values generated)
(2,978 real changes made)
(100,497 missing values generated)
(4,416 real changes made)
(100,497 missing values generated)
(4,528 real changes made)
(100,497 missing values generated)
(4,505 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,896 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,896 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(146,734 missing values generated)
(7,294 real changes made)
(146,734 missing values generated)
(10,739 real changes made)
(146,734 missing values generated)
(11,094 real changes made)
(146,734 missing values generated)
(11,127 real changes made)
(146,734 missing values generated)
(11,136 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(25,134 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(25,134 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(196,638 missing values generated)
(1,286 real changes made)
(196,638 missing values generated)
(67 real changes made)
(196,638 missing values generated)
(77 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,019 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,019 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(207,788 missing values generated)
(1,215 real changes made)
(207,788 missing values generated)
(2,080 real changes made)
(207,788 missing values generated)
(2,342 real changes made)
(207,788 missing values generated)
(2,414 real changes made)
(207,788 missing values generated)
(2,428 real changes made)
(207,788 missing values generated)
(2,448 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,414 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,414 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(138,954 missing values generated)
(2,507 real changes made)
(138,954 missing values generated)
(2,637 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,407 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,407 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(87,921 missing values generated)
(958 real changes made)
(87,921 missing values generated)
(876 real changes made)
(87,921 missing values generated)
(884 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,123 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,123 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(149,879 missing values generated)
(490 real changes made)
(149,879 missing values generated)
(343 real changes made)
(149,879 missing values generated)
(331 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(827 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(827 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(196,638 missing values generated)
(416 real changes made)
(196,638 missing values generated)
(614 real changes made)
(196,638 missing values generated)
(641 real changes made)
(196,638 missing values generated)
(657 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,503 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,503 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(142,858 real changes made, 138,954 to missing)
(217,219 real changes made, 213,315 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2002.dta saved
(27 vars, 216,424 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(99,540 missing values generated)
(3,312 real changes made)
(99,540 missing values generated)
(4,911 real changes made)
(99,540 missing values generated)
(4,992 real changes made)
(99,540 missing values generated)
(4,973 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,706 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,706 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(146,653 missing values generated)
(7,882 real changes made)
(146,653 missing values generated)
(11,835 real changes made)
(146,653 missing values generated)
(12,064 real changes made)
(146,653 missing values generated)
(12,104 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(26,928 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(26,928 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(196,040 missing values generated)
(1,244 real changes made)
(196,040 missing values generated)
(176 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,997 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,997 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(207,039 missing values generated)
(1,242 real changes made)
(207,039 missing values generated)
(2,225 real changes made)
(207,039 missing values generated)
(2,448 real changes made)
(207,039 missing values generated)
(2,514 real changes made)
(207,039 missing values generated)
(2,526 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,621 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,621 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(138,114 missing values generated)
(2,563 real changes made)
(138,114 missing values generated)
(3,005 real changes made)
(138,114 missing values generated)
(3,018 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(7,991 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(7,991 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(86,964 missing values generated)
(1,038 real changes made)
(86,964 missing values generated)
(924 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,156 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,156 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(149,844 missing values generated)
(485 real changes made)
(149,844 missing values generated)
(370 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(862 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(862 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(196,040 missing values generated)
(331 real changes made)
(196,040 missing values generated)
(606 real changes made)
(196,040 missing values generated)
(653 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,431 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,431 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(142,022 real changes made, 138,114 to missing)
(216,424 real changes made, 212,516 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2003.dta saved
(27 vars, 213,241 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(98,369 missing values generated)
(3,466 real changes made)
(98,369 missing values generated)
(5,026 real changes made)
(98,369 missing values generated)
(5,222 real changes made)
(98,369 missing values generated)
(5,209 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,054 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,054 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(144,998 missing values generated)
(8,089 real changes made)
(144,998 missing values generated)
(11,960 real changes made)
(144,998 missing values generated)
(12,330 real changes made)
(144,998 missing values generated)
(12,366 real changes made)
(144,998 missing values generated)
(12,373 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(27,952 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(27,952 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(192,872 missing values generated)
(1,196 real changes made)
(192,872 missing values generated)
(313 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,106 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,106 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(203,484 missing values generated)
(1,260 real changes made)
(203,484 missing values generated)
(2,179 real changes made)
(203,484 missing values generated)
(2,441 real changes made)
(203,484 missing values generated)
(2,499 real changes made)
(203,484 missing values generated)
(2,518 real changes made)
(203,484 missing values generated)
(2,527 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,694 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,694 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(136,092 missing values generated)
(2,772 real changes made)
(136,092 missing values generated)
(3,299 real changes made)
(136,092 missing values generated)
(3,350 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,655 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,655 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(85,430 missing values generated)
(1,059 real changes made)
(85,430 missing values generated)
(722 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,971 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,971 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(148,180 missing values generated)
(492 real changes made)
(148,180 missing values generated)
(345 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(865 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(865 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(192,872 missing values generated)
(360 real changes made)
(192,872 missing values generated)
(543 real changes made)
(192,872 missing values generated)
(574 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,387 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,387 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(139,924 real changes made, 136,092 to missing)
(213,241 real changes made, 209,409 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2004.dta saved
(27 vars, 210,648 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(97,339 missing values generated)
(4,045 real changes made)
(97,339 missing values generated)
(4,613 real changes made)
(97,339 missing values generated)
(4,572 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,060 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,060 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,530 missing values generated)
(7,966 real changes made)
(143,530 missing values generated)
(12,543 real changes made)
(143,530 missing values generated)
(13,175 real changes made)
(143,530 missing values generated)
(13,277 real changes made)
(143,530 missing values generated)
(13,300 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(28,739 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(28,739 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(190,087 missing values generated)
(1,333 real changes made)
(190,087 missing values generated)
(394 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,311 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,311 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(200,988 missing values generated)
(1,368 real changes made)
(200,988 missing values generated)
(2,272 real changes made)
(200,988 missing values generated)
(2,446 real changes made)
(200,988 missing values generated)
(2,493 real changes made)
(200,988 missing values generated)
(2,513 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,743 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,743 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(134,201 missing values generated)
(2,781 real changes made)
(134,201 missing values generated)
(3,991 real changes made)
(134,201 missing values generated)
(3,958 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,357 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,357 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(84,691 missing values generated)
(1,071 real changes made)
(84,691 missing values generated)
(867 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,139 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,139 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(146,518 missing values generated)
(481 real changes made)
(146,518 missing values generated)
(378 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(889 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(889 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(190,087 missing values generated)
(356 real changes made)
(190,087 missing values generated)
(640 real changes made)
(190,087 missing values generated)
(680 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,427 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,427 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(137,737 real changes made, 134,201 to missing)
(210,648 real changes made, 207,112 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2005.dta saved
(27 vars, 208,562 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(95,889 missing values generated)
(4,043 real changes made)
(95,889 missing values generated)
(4,615 real changes made)
(95,889 missing values generated)
(4,577 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,166 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,166 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(142,702 missing values generated)
(7,930 real changes made)
(142,702 missing values generated)
(13,522 real changes made)
(142,702 missing values generated)
(14,183 real changes made)
(142,702 missing values generated)
(14,329 real changes made)
(142,702 missing values generated)
(14,363 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(29,557 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(29,557 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(188,149 missing values generated)
(1,270 real changes made)
(188,149 missing values generated)
(428 real changes made)
(188,149 missing values generated)
(408 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,356 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,356 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(198,946 missing values generated)
(1,324 real changes made)
(198,946 missing values generated)
(2,334 real changes made)
(198,946 missing values generated)
(2,526 real changes made)
(198,946 missing values generated)
(2,573 real changes made)
(198,946 missing values generated)
(2,593 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,850 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,850 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,623 missing values generated)
(2,939 real changes made)
(132,623 missing values generated)
(4,077 real changes made)
(132,623 missing values generated)
(4,114 real changes made)
(132,623 missing values generated)
(4,125 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,655 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,655 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(83,223 missing values generated)
(1,038 real changes made)
(83,223 missing values generated)
(957 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,126 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,126 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(145,752 missing values generated)
(485 real changes made)
(145,752 missing values generated)
(388 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(910 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(910 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(188,149 missing values generated)
(374 real changes made)
(188,149 missing values generated)
(676 real changes made)
(188,149 missing values generated)
(661 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,418 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,418 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(136,147 real changes made, 132,623 to missing)
(208,562 real changes made, 205,038 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2006.dta saved
(27 vars, 206,639 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(94,282 missing values generated)
(4,192 real changes made)
(94,282 missing values generated)
(4,402 real changes made)
(94,282 missing values generated)
(4,447 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,930 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,930 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(141,844 missing values generated)
(8,003 real changes made)
(141,844 missing values generated)
(13,640 real changes made)
(141,844 missing values generated)
(14,268 real changes made)
(141,844 missing values generated)
(14,420 real changes made)
(141,844 missing values generated)
(14,445 real changes made)
(141,844 missing values generated)
(14,459 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(29,401 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(29,401 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(186,147 missing values generated)
(1,315 real changes made)
(186,147 missing values generated)
(327 real changes made)
(186,147 missing values generated)
(358 real changes made)
(186,147 missing values generated)
(346 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,210 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,210 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(197,644 missing values generated)
(1,238 real changes made)
(197,644 missing values generated)
(2,315 real changes made)
(197,644 missing values generated)
(2,576 real changes made)
(197,644 missing values generated)
(2,648 real changes made)
(197,644 missing values generated)
(2,675 real changes made)
(197,644 missing values generated)
(2,697 real changes made)
(197,644 missing values generated)
(2,704 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,683 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,683 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(131,162 missing values generated)
(2,654 real changes made)
(131,162 missing values generated)
(4,373 real changes made)
(131,162 missing values generated)
(4,508 real changes made)
(131,162 missing values generated)
(4,518 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,718 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,718 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(82,213 missing values generated)
(967 real changes made)
(82,213 missing values generated)
(1,042 real changes made)
(82,213 missing values generated)
(1,033 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,075 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,075 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(144,918 missing values generated)
(524 real changes made)
(144,918 missing values generated)
(324 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(885 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(885 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(186,147 missing values generated)
(349 real changes made)
(186,147 missing values generated)
(701 real changes made)
(186,147 missing values generated)
(740 real changes made)
(186,147 missing values generated)
(748 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,386 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,386 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(134,542 real changes made, 131,162 to missing)
(206,639 real changes made, 203,259 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2007.dta saved
(27 vars, 206,404 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(93,895 missing values generated)
(4,172 real changes made)
(93,895 missing values generated)
(4,179 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,738 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,738 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(142,477 missing values generated)
(8,003 real changes made)
(142,477 missing values generated)
(13,285 real changes made)
(142,477 missing values generated)
(14,016 real changes made)
(142,477 missing values generated)
(14,203 real changes made)
(142,477 missing values generated)
(14,252 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(29,458 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(29,458 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(185,447 missing values generated)
(1,235 real changes made)
(185,447 missing values generated)
(246 real changes made)
(185,447 missing values generated)
(261 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,053 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,053 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(197,393 missing values generated)
(1,286 real changes made)
(197,393 missing values generated)
(2,430 real changes made)
(197,393 missing values generated)
(2,684 real changes made)
(197,393 missing values generated)
(2,765 real changes made)
(197,393 missing values generated)
(2,797 real changes made)
(197,393 missing values generated)
(2,812 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,877 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,877 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(130,532 missing values generated)
(2,801 real changes made)
(130,532 missing values generated)
(4,303 real changes made)
(130,532 missing values generated)
(4,326 real changes made)
(130,532 missing values generated)
(4,333 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,687 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,687 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(81,752 missing values generated)
(1,046 real changes made)
(81,752 missing values generated)
(1,037 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,160 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,160 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(145,609 missing values generated)
(420 real changes made)
(145,609 missing values generated)
(472 real changes made)
(145,609 missing values generated)
(460 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(931 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(931 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(185,447 missing values generated)
(322 real changes made)
(185,447 missing values generated)
(671 real changes made)
(185,447 missing values generated)
(685 real changes made)
(185,447 missing values generated)
(695 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,380 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,380 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(133,915 real changes made, 130,532 to missing)
(206,404 real changes made, 203,021 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2008.dta saved
(27 vars, 207,921 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(94,833 missing values generated)
(4,580 real changes made)
(94,833 missing values generated)
(4,251 real changes made)
(94,833 missing values generated)
(4,291 real changes made)
(94,833 missing values generated)
(4,269 real changes made)
(94,833 missing values generated)
(4,289 real changes made)
(94,833 missing values generated)
(4,271 real changes made)
(94,833 missing values generated)
(4,288 real changes made)
(94,833 missing values generated)
(4,275 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,463 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,463 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(144,000 missing values generated)
(8,195 real changes made)
(144,000 missing values generated)
(13,223 real changes made)
(144,000 missing values generated)
(13,871 real changes made)
(144,000 missing values generated)
(14,026 real changes made)
(144,000 missing values generated)
(14,057 real changes made)
(144,000 missing values generated)
(14,068 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(30,447 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(30,447 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(186,519 missing values generated)
(1,310 real changes made)
(186,519 missing values generated)
(289 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,172 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,172 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(198,411 missing values generated)
(1,382 real changes made)
(198,411 missing values generated)
(2,491 real changes made)
(198,411 missing values generated)
(2,724 real changes made)
(198,411 missing values generated)
(2,808 real changes made)
(198,411 missing values generated)
(2,815 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,097 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,097 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(131,736 missing values generated)
(3,283 real changes made)
(131,736 missing values generated)
(4,290 real changes made)
(131,736 missing values generated)
(4,320 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(10,536 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(10,536 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(82,160 missing values generated)
(1,132 real changes made)
(82,160 missing values generated)
(938 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,228 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,228 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(147,163 missing values generated)
(539 real changes made)
(147,163 missing values generated)
(379 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(928 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(928 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(186,519 missing values generated)
(349 real changes made)
(186,519 missing values generated)
(667 real changes made)
(186,519 missing values generated)
(699 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,386 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,386 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(135,253 real changes made, 131,736 to missing)
(207,921 real changes made, 204,404 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2009.dta saved
(27 vars, 209,802 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(95,379 missing values generated)
(5,376 real changes made)
(95,379 missing values generated)
(4,112 real changes made)
(95,379 missing values generated)
(4,147 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(11,447 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(11,447 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(145,943 missing values generated)
(8,615 real changes made)
(145,943 missing values generated)
(13,488 real changes made)
(145,943 missing values generated)
(14,051 real changes made)
(145,943 missing values generated)
(14,244 real changes made)
(145,943 missing values generated)
(14,264 real changes made)
(145,943 missing values generated)
(14,267 real changes made)
(145,943 missing values generated)
(14,275 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(32,470 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(32,470 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(187,946 missing values generated)
(1,367 real changes made)
(187,946 missing values generated)
(191 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,149 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,149 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(200,138 missing values generated)
(1,497 real changes made)
(200,138 missing values generated)
(2,491 real changes made)
(200,138 missing values generated)
(2,744 real changes made)
(200,138 missing values generated)
(2,795 real changes made)
(200,138 missing values generated)
(2,812 real changes made)
(200,138 missing values generated)
(2,829 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,255 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,255 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(133,542 missing values generated)
(3,877 real changes made)
(133,542 missing values generated)
(5,247 real changes made)
(133,542 missing values generated)
(5,322 real changes made)
(133,542 missing values generated)
(5,337 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(13,002 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(13,002 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(82,587 missing values generated)
(1,132 real changes made)
(82,587 missing values generated)
(1,032 real changes made)
(82,587 missing values generated)
(1,045 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,387 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,387 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(149,071 missing values generated)
(560 real changes made)
(149,071 missing values generated)
(433 real changes made)
(149,071 missing values generated)
(442 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(981 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(981 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(187,946 missing values generated)
(346 real changes made)
(187,946 missing values generated)
(652 real changes made)
(187,946 missing values generated)
(688 real changes made)
(187,946 missing values generated)
(712 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,392 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,392 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(137,196 real changes made, 133,542 to missing)
(209,802 real changes made, 206,148 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2010.dta saved
(27 vars, 204,983 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(92,695 missing values generated)
(5,392 real changes made)
(92,695 missing values generated)
(4,872 real changes made)
(92,695 missing values generated)
(4,906 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(11,957 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(11,957 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,718 missing values generated)
(8,712 real changes made)
(143,718 missing values generated)
(13,271 real changes made)
(143,718 missing values generated)
(14,232 real changes made)
(143,718 missing values generated)
(14,482 real changes made)
(143,718 missing values generated)
(14,559 real changes made)
(143,718 missing values generated)
(14,582 real changes made)
(143,718 missing values generated)
(14,589 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(32,061 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(32,061 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(183,037 missing values generated)
(1,354 real changes made)
(183,037 missing values generated)
(333 real changes made)
(183,037 missing values generated)
(346 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,205 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,205 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(195,499 missing values generated)
(1,422 real changes made)
(195,499 missing values generated)
(2,503 real changes made)
(195,499 missing values generated)
(2,709 real changes made)
(195,499 missing values generated)
(2,787 real changes made)
(195,499 missing values generated)
(2,810 real changes made)
(195,499 missing values generated)
(2,827 real changes made)
(195,499 missing values generated)
(2,830 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,152 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,152 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(129,795 missing values generated)
(4,295 real changes made)
(129,795 missing values generated)
(6,250 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(14,911 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(14,911 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(80,144 missing values generated)
(1,131 real changes made)
(80,144 missing values generated)
(1,090 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,436 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,436 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(146,785 missing values generated)
(488 real changes made)
(146,785 missing values generated)
(501 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(998 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(998 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(183,037 missing values generated)
(352 real changes made)
(183,037 missing values generated)
(711 real changes made)
(183,037 missing values generated)
(740 real changes made)
(183,037 missing values generated)
(747 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,422 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,422 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(133,380 real changes made, 129,795 to missing)
(204,983 real changes made, 201,398 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2011.dta saved
(27 vars, 201,398 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(91,671 missing values generated)
(5,560 real changes made)
(91,671 missing values generated)
(4,797 real changes made)
(91,671 missing values generated)
(4,765 real changes made)
(91,671 missing values generated)
(4,776 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(12,071 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(12,071 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(141,857 missing values generated)
(8,473 real changes made)
(141,857 missing values generated)
(13,777 real changes made)
(141,857 missing values generated)
(14,911 real changes made)
(141,857 missing values generated)
(15,299 real changes made)
(141,857 missing values generated)
(15,416 real changes made)
(141,857 missing values generated)
(15,460 real changes made)
(141,857 missing values generated)
(15,476 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(32,816 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(32,816 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(178,891 missing values generated)
(1,413 real changes made)
(178,891 missing values generated)
(137 real changes made)
(178,891 missing values generated)
(155 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,163 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,163 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(191,775 missing values generated)
(1,560 real changes made)
(191,775 missing values generated)
(2,546 real changes made)
(191,775 missing values generated)
(2,718 real changes made)
(191,775 missing values generated)
(2,762 real changes made)
(191,775 missing values generated)
(2,769 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,329 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,329 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(127,015 missing values generated)
(4,235 real changes made)
(127,015 missing values generated)
(6,894 real changes made)
(127,015 missing values generated)
(6,940 real changes made)
(127,015 missing values generated)
(6,943 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(15,648 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(15,648 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(79,102 missing values generated)
(1,275 real changes made)
(79,102 missing values generated)
(981 real changes made)
(79,102 missing values generated)
(997 real changes made)
(79,102 missing values generated)
(1,010 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,545 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,545 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(144,803 missing values generated)
(454 real changes made)
(144,803 missing values generated)
(488 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(990 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(990 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(178,891 missing values generated)
(413 real changes made)
(178,891 missing values generated)
(621 real changes made)
(178,891 missing values generated)
(636 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,426 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,426 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(130,737 real changes made, 127,015 to missing)
(201,398 real changes made, 197,676 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2012.dta saved
(27 vars, 202,634 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(92,606 missing values generated)
(5,617 real changes made)
(92,606 missing values generated)
(5,259 real changes made)
(92,606 missing values generated)
(5,229 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(12,487 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(12,487 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(143,047 missing values generated)
(8,586 real changes made)
(143,047 missing values generated)
(14,448 real changes made)
(143,047 missing values generated)
(15,617 real changes made)
(143,047 missing values generated)
(16,030 real changes made)
(143,047 missing values generated)
(16,227 real changes made)
(143,047 missing values generated)
(16,307 real changes made)
(143,047 missing values generated)
(16,331 real changes made)
(143,047 missing values generated)
(16,343 real changes made)
(143,047 missing values generated)
(16,356 real changes made)
(143,047 missing values generated)
(16,365 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(33,807 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(33,807 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(179,188 missing values generated)
(1,382 real changes made)
(179,188 missing values generated)
(313 real changes made)
(179,188 missing values generated)
(337 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,266 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,266 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(193,061 missing values generated)
(1,541 real changes made)
(193,061 missing values generated)
(2,655 real changes made)
(193,061 missing values generated)
(2,864 real changes made)
(193,061 missing values generated)
(2,938 real changes made)
(193,061 missing values generated)
(2,964 real changes made)
(193,061 missing values generated)
(2,971 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(6,476 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(6,476 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(127,813 missing values generated)
(4,399 real changes made)
(127,813 missing values generated)
(7,104 real changes made)
(127,813 missing values generated)
(7,450 real changes made)
(127,813 missing values generated)
(7,485 real changes made)
(127,813 missing values generated)
(7,503 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(16,349 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(16,349 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(80,318 missing values generated)
(1,194 real changes made)
(80,318 missing values generated)
(918 real changes made)
(80,318 missing values generated)
(908 real changes made)
(80,318 missing values generated)
(894 real changes made)
(80,318 missing values generated)
(904 real changes made)
(80,318 missing values generated)
(894 real changes made)
(80,318 missing values generated)
(904 real changes made)
(80,318 missing values generated)
(894 real changes made)
(80,318 missing values generated)
(904 real changes made)
(80,318 missing values generated)
(894 real changes made)
(80,318 missing values generated)
(903 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,388 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,388 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(145,762 missing values generated)
(452 real changes made)
(145,762 missing values generated)
(502 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(994 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(994 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(179,188 missing values generated)
(366 real changes made)
(179,188 missing values generated)
(617 real changes made)
(179,188 missing values generated)
(672 real changes made)
(179,188 missing values generated)
(678 real changes made)
(179,188 missing values generated)
(689 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,368 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,368 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(131,521 real changes made, 127,813 to missing)
(202,634 real changes made, 198,926 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2013.dta saved
(27 vars, 139,415 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(63,801 missing values generated)
(4,846 real changes made)
(63,801 missing values generated)
(2,695 real changes made)
(63,801 missing values generated)
(2,703 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(8,503 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(8,503 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(98,738 missing values generated)
(6,472 real changes made)
(98,738 missing values generated)
(11,014 real changes made)
(98,738 missing values generated)
(12,200 real changes made)
(98,738 missing values generated)
(12,753 real changes made)
(98,738 missing values generated)
(13,052 real changes made)
(98,738 missing values generated)
(13,221 real changes made)
(98,738 missing values generated)
(13,314 real changes made)
(98,738 missing values generated)
(13,380 real changes made)
(98,738 missing values generated)
(13,406 real changes made)
(98,738 missing values generated)
(13,423 real changes made)
(98,738 missing values generated)
(13,429 real changes made)
(98,738 missing values generated)
(13,439 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(24,490 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(24,490 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(122,869 missing values generated)
(694 real changes made)
(122,869 missing values generated)
(529 real changes made)
(122,869 missing values generated)
(540 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,592 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,592 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,837 missing values generated)
(1,118 real changes made)
(132,837 missing values generated)
(1,816 real changes made)
(132,837 missing values generated)
(1,928 real changes made)
(132,837 missing values generated)
(1,959 real changes made)
(132,837 missing values generated)
(1,977 real changes made)
(132,837 missing values generated)
(1,980 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,326 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,326 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(87,917 missing values generated)
(3,074 real changes made)
(87,917 missing values generated)
(5,130 real changes made)
(87,917 missing values generated)
(5,254 real changes made)
(87,917 missing values generated)
(5,264 real changes made)
(87,917 missing values generated)
(5,274 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(11,501 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(11,501 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(55,328 missing values generated)
(864 real changes made)
(55,328 missing values generated)
(684 real changes made)
(55,328 missing values generated)
(692 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,334 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,334 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(100,633 missing values generated)
(333 real changes made)
(100,633 missing values generated)
(370 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(705 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(705 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(122,869 missing values generated)
(236 real changes made)
(122,869 missing values generated)
(405 real changes made)
(122,869 missing values generated)
(444 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(972 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(972 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(90,478 real changes made, 87,917 to missing)
(139,415 real changes made, 136,854 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2014.dta saved
(27 vars, 199,024 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(92,865 missing values generated)
(8,232 real changes made)
(92,865 missing values generated)
(9,082 real changes made)
(92,865 missing values generated)
(9,070 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(18,478 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(18,478 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(141,540 missing values generated)
(9,970 real changes made)
(141,540 missing values generated)
(14,062 real changes made)
(141,540 missing values generated)
(14,867 real changes made)
(141,540 missing values generated)
(15,041 real changes made)
(141,540 missing values generated)
(15,116 real changes made)
(141,540 missing values generated)
(15,137 real changes made)
(141,540 missing values generated)
(15,148 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(30,566 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(30,566 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(174,198 missing values generated)
(1,100 real changes made)
(174,198 missing values generated)
(978 real changes made)
(174,198 missing values generated)
(1,000 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,623 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,623 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(188,469 missing values generated)
(1,842 real changes made)
(188,469 missing values generated)
(1,902 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,740 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,740 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(124,767 missing values generated)
(4,572 real changes made)
(124,767 missing values generated)
(6,849 real changes made)
(124,767 missing values generated)
(6,996 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(16,170 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(16,170 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(79,571 missing values generated)
(1,336 real changes made)
(79,571 missing values generated)
(594 real changes made)
(79,571 missing values generated)
(584 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,265 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,265 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(144,279 missing values generated)
(411 real changes made)
(144,279 missing values generated)
(530 real changes made)
(144,279 missing values generated)
(549 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(982 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(982 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(174,198 missing values generated)
(412 real changes made)
(174,198 missing values generated)
(483 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,379 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,379 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(128,515 real changes made, 124,767 to missing)
(199,024 real changes made, 195,276 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2015.dta saved
(27 vars, 185,487 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(87,226 missing values generated)
(8,203 real changes made)
(87,226 missing values generated)
(11,571 real changes made)
(87,226 missing values generated)
(11,657 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(20,774 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(20,774 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,004 missing values generated)
(9,569 real changes made)
(132,004 missing values generated)
(14,642 real changes made)
(132,004 missing values generated)
(15,941 real changes made)
(132,004 missing values generated)
(16,384 real changes made)
(132,004 missing values generated)
(16,617 real changes made)
(132,004 missing values generated)
(16,716 real changes made)
(132,004 missing values generated)
(16,779 real changes made)
(132,004 missing values generated)
(16,794 real changes made)
(132,004 missing values generated)
(16,800 real changes made)
(132,004 missing values generated)
(16,807 real changes made)
(132,004 missing values generated)
(16,810 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(30,893 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(30,893 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(161,790 missing values generated)
(1,081 real changes made)
(161,790 missing values generated)
(1,006 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,485 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,485 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(175,441 missing values generated)
(1,848 real changes made)
(175,441 missing values generated)
(1,912 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,502 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,502 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(116,003 missing values generated)
(4,302 real changes made)
(116,003 missing values generated)
(6,651 real changes made)
(116,003 missing values generated)
(6,758 real changes made)
(116,003 missing values generated)
(6,777 real changes made)
(116,003 missing values generated)
(6,782 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(15,134 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(15,134 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(74,622 missing values generated)
(1,270 real changes made)
(74,622 missing values generated)
(671 real changes made)
(74,622 missing values generated)
(647 real changes made)
(74,622 missing values generated)
(649 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,117 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,117 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(134,562 missing values generated)
(407 real changes made)
(134,562 missing values generated)
(529 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(940 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(940 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(161,790 missing values generated)
(296 real changes made)
(161,790 missing values generated)
(588 real changes made)
(161,790 missing values generated)
(582 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,287 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,287 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(119,440 real changes made, 116,003 to missing)
(185,487 real changes made, 182,050 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2016.dta saved
(27 vars, 185,914 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(87,625 missing values generated)
(8,198 real changes made)
(87,625 missing values generated)
(12,281 real changes made)
(87,625 missing values generated)
(12,337 real changes made)
(87,625 missing values generated)
(12,351 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(21,836 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(21,802 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(133,276 missing values generated)
(9,050 real changes made)
(133,276 missing values generated)
(14,926 real changes made)
(133,276 missing values generated)
(16,260 real changes made)
(133,276 missing values generated)
(16,832 real changes made)
(133,276 missing values generated)
(17,215 real changes made)
(133,276 missing values generated)
(17,412 real changes made)
(133,276 missing values generated)
(17,515 real changes made)
(133,276 missing values generated)
(17,572 real changes made)
(133,276 missing values generated)
(17,595 real changes made)
(133,276 missing values generated)
(17,609 real changes made)
(133,276 missing values generated)
(17,626 real changes made)
(133,276 missing values generated)
(17,628 real changes made)
(133,276 missing values generated)
(17,637 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(31,932 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(31,909 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(160,986 missing values generated)
(1,118 real changes made)
(160,986 missing values generated)
(1,023 real changes made)
(160,986 missing values generated)
(1,016 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,659 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,658 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(175,855 missing values generated)
(1,846 real changes made)
(175,855 missing values generated)
(1,754 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,482 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,482 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,957 missing values generated)
(4,098 real changes made)
(115,957 missing values generated)
(6,697 real changes made)
(115,957 missing values generated)
(6,652 real changes made)
(115,957 missing values generated)
(6,628 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,640 real changes made)
(115,957 missing values generated)
(6,633 real changes made)
(115,957 missing values generated)
(6,638 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(14,619 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(14,619 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(75,092 missing values generated)
(1,233 real changes made)
(75,092 missing values generated)
(652 real changes made)
(75,092 missing values generated)
(687 real changes made)
(75,092 missing values generated)
(676 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(3,131 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(3,131 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(135,750 missing values generated)
(314 real changes made)
(135,750 missing values generated)
(706 real changes made)
(135,750 missing values generated)
(599 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(940 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(940 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(160,986 missing values generated)
(378 real changes made)
(160,986 missing values generated)
(525 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,333 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,333 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(119,390 real changes made, 115,957 to missing)
(185,914 real changes made, 182,481 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2017.dta saved
(27 vars, 180,084 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(85,022 missing values generated)
(8,429 real changes made)
(85,022 missing values generated)
(12,121 real changes made)
(85,022 missing values generated)
(12,215 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(20,794 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(20,764 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(129,728 missing values generated)
(9,285 real changes made)
(129,728 missing values generated)
(15,173 real changes made)
(129,728 missing values generated)
(16,594 real changes made)
(129,728 missing values generated)
(17,293 real changes made)
(129,728 missing values generated)
(17,702 real changes made)
(129,728 missing values generated)
(17,911 real changes made)
(129,728 missing values generated)
(18,019 real changes made)
(129,728 missing values generated)
(18,095 real changes made)
(129,728 missing values generated)
(18,130 real changes made)
(129,728 missing values generated)
(18,155 real changes made)
(129,728 missing values generated)
(18,169 real changes made)
(129,728 missing values generated)
(18,182 real changes made)
(129,728 missing values generated)
(18,187 real changes made)
(129,728 missing values generated)
(18,192 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(30,718 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(30,685 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(154,625 missing values generated)
(1,218 real changes made)
(154,625 missing values generated)
(985 real changes made)
(154,625 missing values generated)
(961 real changes made)
(154,625 missing values generated)
(968 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,624 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,621 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(170,877 missing values generated)
(1,846 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,125 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,125 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(112,175 missing values generated)
(3,746 real changes made)
(112,175 missing values generated)
(6,352 real changes made)
(112,175 missing values generated)
(6,474 real changes made)
(112,175 missing values generated)
(6,498 real changes made)
(112,175 missing values generated)
(6,505 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(13,249 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(13,249 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(73,399 missing values generated)
(1,249 real changes made)
(73,399 missing values generated)
(617 real changes made)
(73,399 missing values generated)
(628 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,962 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,962 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,144 missing values generated)
(325 real changes made)
(132,144 missing values generated)
(497 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(830 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(830 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(154,625 missing values generated)
(378 real changes made)
(154,625 missing values generated)
(493 real changes made)
(154,625 missing values generated)
(516 real changes made)
(154,625 missing values generated)
(519 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,323 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,323 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(115,367 real changes made, 112,175 to missing)
(180,084 real changes made, 176,892 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2018.dta saved
(27 vars, 180,101 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(84,843 missing values generated)
(7,950 real changes made)
(84,843 missing values generated)
(12,682 real changes made)
(84,843 missing values generated)
(12,980 real changes made)
(84,843 missing values generated)
(13,004 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(21,064 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(21,051 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(130,404 missing values generated)
(8,681 real changes made)
(130,404 missing values generated)
(14,553 real changes made)
(130,404 missing values generated)
(16,010 real changes made)
(130,404 missing values generated)
(16,726 real changes made)
(130,404 missing values generated)
(17,136 real changes made)
(130,404 missing values generated)
(17,394 real changes made)
(130,404 missing values generated)
(17,570 real changes made)
(130,404 missing values generated)
(17,631 real changes made)
(130,404 missing values generated)
(17,687 real changes made)
(130,404 missing values generated)
(17,731 real changes made)
(130,404 missing values generated)
(17,743 real changes made)
(130,404 missing values generated)
(17,754 real changes made)
(130,404 missing values generated)
(17,757 real changes made)
(130,404 missing values generated)
(17,759 real changes made)
(130,404 missing values generated)
(17,761 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(30,548 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(30,535 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(153,809 missing values generated)
(1,200 real changes made)
(153,809 missing values generated)
(1,256 real changes made)
(153,809 missing values generated)
(1,260 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,710 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,710 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(171,247 missing values generated)
(1,821 real changes made)
(171,247 missing values generated)
(2,080 real changes made)
(171,247 missing values generated)
(2,126 real changes made)
(171,247 missing values generated)
(2,128 real changes made)
(171,247 missing values generated)
(2,136 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(5,110 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(5,110 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(111,756 missing values generated)
(3,842 real changes made)
(111,756 missing values generated)
(5,744 real changes made)
(111,756 missing values generated)
(5,853 real changes made)
(111,756 missing values generated)
(5,877 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(12,726 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(12,726 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(73,525 missing values generated)
(1,226 real changes made)
(73,525 missing values generated)
(845 real changes made)
(73,525 missing values generated)
(834 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,986 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,986 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,868 missing values generated)
(273 real changes made)
(132,868 missing values generated)
(514 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(824 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(824 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(153,809 missing values generated)
(382 real changes made)
(153,809 missing values generated)
(559 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,369 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,369 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(115,113 real changes made, 111,756 to missing)
(180,101 real changes made, 176,744 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2019.dta saved
(27 vars, 157,959 obs)
(40 observations deleted)

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(74,840 missing values generated)
(6,658 real changes made)
(74,840 missing values generated)
(10,261 real changes made)
(74,840 missing values generated)
(10,430 real changes made)
(74,840 missing values generated)
(10,440 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(17,349 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(17,330 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(115,662 missing values generated)
(7,174 real changes made)
(115,662 missing values generated)
(12,135 real changes made)
(115,662 missing values generated)
(13,471 real changes made)
(115,662 missing values generated)
(14,103 real changes made)
(115,662 missing values generated)
(14,416 real changes made)
(115,662 missing values generated)
(14,626 real changes made)
(115,662 missing values generated)
(14,743 real changes made)
(115,662 missing values generated)
(14,818 real changes made)
(115,662 missing values generated)
(14,863 real changes made)
(115,662 missing values generated)
(14,890 real changes made)
(115,662 missing values generated)
(14,900 real changes made)
(115,662 missing values generated)
(14,910 real changes made)
(115,662 missing values generated)
(14,919 real changes made)
(115,662 missing values generated)
(14,927 real changes made)
(115,662 missing values generated)
(14,931 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(25,224 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(25,213 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,814 missing values generated)
(1,032 real changes made)
(132,814 missing values generated)
(1,150 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,420 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,420 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(150,561 missing values generated)
(1,512 real changes made)
(150,561 missing values generated)
(1,944 real changes made)
(150,561 missing values generated)
(2,014 real changes made)
(150,561 missing values generated)
(2,024 real changes made)
(150,561 missing values generated)
(2,034 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(4,432 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(4,432 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(97,499 missing values generated)
(3,150 real changes made)
(97,499 missing values generated)
(4,524 real changes made)
(97,499 missing values generated)
(4,600 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(9,949 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(9,949 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(65,341 missing values generated)
(997 real changes made)
(65,341 missing values generated)
(649 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(2,434 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(2,434 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(117,763 missing values generated)
(243 real changes made)
(117,763 missing values generated)
(388 real changes made)
(117,763 missing values generated)
(401 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(649 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(649 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file

. /*
> ******************************************************************************************
> ** Program:    assign_transfer_receipt.do
> **
> ** Purpose:    Uses probabilites and random numbers from CBO's means-tested transfer
> **             imputation model to assign non-reporters in the CPS as transfer recipients.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. local group `1'

. 
. qui sum `group'_target_recipients

. local `group'_target = r(mean)

. 
. // Create a "program" local for each group (which comes in the form of "program_subgroup", 
. // because some variables will be calculated at the program level.
. local program = substr("`group'", 1, strpos("`group'", "_") - 1)

. 
. // Calculate the total numbers of reported and reported + imputed recipients.
. qui sum `program'_report [w=hsup_wgt] if `program'_report == 1 & `group' == 1

. local tot_`group'_report = r(sum_w)

. local tot_`group'_impute = r(sum_w)

. 
. // Calculate the total number of units (recipient or nonrecipient) in a subgroup.
. qui sum `group' [w=hsup_wgt] if `group' == 1

. local total_`group' = r(sum_w)

. 
. // Create an adjustment factor for the random number. There is no
. // adjustment in the first round, so the factor is set to 1.
. local adj_factor = 1

. 
. // The algorithm is designed to get the final reported + imputed total to
. // within one weighted household of the target. This algorithm takes the
. // maximum value of hsup_wgt as a proxy for one weighted household.
. qui sum hsup_wgt, detail

. local stopping_threshold = r(max)

. 
. // Loop until the final imputed + reported total is within one weighted
. // household of the target.
. local i_loop = 0

. while abs(`tot_`group'_impute' - ``group'_target') > `stopping_threshold' {
  2. 
.   local ++i_loop
  3. 
.   // To start, set the imputed + reported series to be equal to the
.   // reported series.
.   gen `group'_impute_`i_loop' = `program'_report if `group' == 1
  4. 
.   // If the number of reporting units is below the target (typically
.   // the case), assign receipt if a unit's estimated probability of
.   // receipt exceeds the random number.
.   if `tot_`group'_report' < ``group'_target' ///
>     replace `group'_impute_`i_loop' = 1 ///
>     if `program'_prob > (`program'_rand * `adj_factor') & `group' == 1
  5. 
.   // In the few cases where the number of reporters exceeds the target,
.   // remove reported receipt if a unit's probability is lower than the
.   // random number.
.   else ///
>     replace `group'_impute_`i_loop' = 0 ///
>     if `program'_prob < (`program'_rand * `adj_factor') & `group' == 1
  6. 
.   // Calculate the new total.
.   qui sum `group'_impute_`i_loop' [w=hsup_wgt] if `group'_impute_`i_loop' == 1
  7.   local tot_`group'_impute = r(sum_w)
  8. 
.   // Calculate the adjustment factor (depending on whether the algorithm
.   // is correcting for underreporting or overreporting).
.   if `tot_`group'_report' < ``group'_target' ///
>     local adj_factor = `adj_factor' * (`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report')
  9.   else ///
>     local adj_factor = `adj_factor' / ((`tot_`group'_impute' - ///
>       `tot_`group'_report') / (``group'_target' - `tot_`group'_report'))
 10. 
. }
(132,814 missing values generated)
(287 real changes made)
(132,814 missing values generated)
(659 real changes made)
(132,814 missing values generated)
(610 real changes made)
(132,814 missing values generated)
(609 real changes made)
(132,814 missing values generated)
(600 real changes made)

. 
. // If no imputation was necessary, set the imputed + reported series equal
. // to the reported series.
. if `i_loop' == 0 ///
>   gen `group'_impute_0 = `program'_report

. 
. // Set the imputed recipiency status for the program equal to the final
. // round of imputations for that particular subgroup.
. replace `program'_impute = `group'_impute_`i_loop' if `group' == 1
(1,270 real changes made)

. 
. replace `program'_impute_val = `program'_potential_val ///
>   if `program'_impute == 1 & `group' == 1
(1,270 real changes made)

. 
. capture drop `group'_impute_*

. 
end of do-file
(100,281 real changes made, 97,499 to missing)
(157,959 real changes made, 155,177 to missing)
file ..\outputs\data\CBO_imputed_means_tested_transfers_2020.dta saved

. 
. 
. /*
> ****************************************************************************************
> ** USE OUTPUT DATASETS TO CREATE CSV WITH SUMMARY STATISTICS
> ****************************************************************************************
> */
. 
. do produce_summary_statistics.do

. /*
> ******************************************************************************************
> ** Program:    produce_summary_statistics.do
> **
> ** Purpose:    Produces a CSV file containing means, medians, and sums for CBO's
> **             means-tested transfer imputations.
> **
> ** Programmer: Bilal Habib
> **
> ** Date:       July 2018
> **             Updated May 2020
> **
> ** NOTE:       This script is called from within impute_means_tested_transfers_MAIN.do
> ******************************************************************************************
> */
. 
. foreach year of numlist $cps_start_year / $cps_end_year {
  2. 
.   use "$output_data_path\CBO_imputed_means_tested_transfers_`year'.dta", clear
  3. 
.     // Remove zeros so that means are calculated only for recipients.
.     foreach program in mcaid snap ssi housing_assist {
  4.       replace `program'_impute_val = . if `program'_impute_val == 0
  5.     }
  6. 
.     // Produce a dataset with means, total recipients, total benefit dollars,
.     // and medians for each year.
.     #delimit ;
delimiter now ;
.     collapse (mean)   cps_year = year
>                       mcaid_mean = mcaid_impute_val
>                       snap_mean = snap_impute_val
>                       ssi_mean = ssi_impute_val
>                       housing_assist_mean = housing_assist_impute_val
> 
>              (sum)    mcaid_total_recipients = mcaid_impute
>                       snap_total_recipients = snap_impute
>                       ssi_total_recipients = ssi_impute
>                       housing_assist_total_recipients = housing_assist_impute
> 
>                       mcaid_total_dollars = mcaid_impute_val
>                       snap_total_dollars = snap_impute_val
>                       ssi_total_dollars = ssi_impute_val
>                       housing_assist_total_dollars = housing_assist_impute_val
> 
>              (median) mcaid_median = mcaid_impute_val
>                       snap_median = snap_impute_val
>                       ssi_median = ssi_impute_val
>                       housing_assist_median = housing_assist_impute_val
> 
>                       [pw = hsup_wgt];
  7.     #delimit cr
delimiter now cr
. 
.     // Save each year's dataset as a temporary file.
.     tempfile summary_`year'
  8.     save `summary_`year'', replace
  9. 
. }
(165,196 real changes made, 165,196 to missing)
(174,077 real changes made, 174,077 to missing)
(177,829 real changes made, 177,829 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000001.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000001.tmp saved
(164,998 real changes made, 164,998 to missing)
(172,829 real changes made, 172,829 to missing)
(177,721 real changes made, 177,721 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000002.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000002.tmp saved
(148,060 real changes made, 148,060 to missing)
(154,674 real changes made, 154,674 to missing)
(159,498 real changes made, 159,498 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000003.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000003.tmp saved
(148,352 real changes made, 148,352 to missing)
(155,062 real changes made, 155,062 to missing)
(159,598 real changes made, 159,598 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000004.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000004.tmp saved
(147,285 real changes made, 147,285 to missing)
(154,088 real changes made, 154,088 to missing)
(158,223 real changes made, 158,223 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000005.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000005.tmp saved
(147,341 real changes made, 147,341 to missing)
(154,638 real changes made, 154,638 to missing)
(158,309 real changes made, 158,309 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000006.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000006.tmp saved
(144,076 real changes made, 144,076 to missing)
(151,352 real changes made, 151,352 to missing)
(154,605 real changes made, 154,605 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000007.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000007.tmp saved
(141,773 real changes made, 141,773 to missing)
(149,374 real changes made, 149,374 to missing)
(152,361 real changes made, 152,361 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000008.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000008.tmp saved
(142,287 real changes made, 142,287 to missing)
(150,241 real changes made, 150,241 to missing)
(152,887 real changes made, 152,887 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000009.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000009.tmp saved
(132,485 real changes made, 132,485 to missing)
(139,483 real changes made, 139,483 to missing)
(141,826 real changes made, 141,826 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000a.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000a.tmp saved
(143,701 real changes made, 143,701 to missing)
(152,108 real changes made, 152,108 to missing)
(154,850 real changes made, 154,850 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000b.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000b.tmp saved
(142,653 real changes made, 142,653 to missing)
(152,029 real changes made, 152,029 to missing)
(155,022 real changes made, 155,022 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000c.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000c.tmp saved
(138,589 real changes made, 138,589 to missing)
(148,495 real changes made, 148,495 to missing)
(152,285 real changes made, 152,285 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000d.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000d.tmp saved
(136,322 real changes made, 136,322 to missing)
(147,194 real changes made, 147,194 to missing)
(151,380 real changes made, 151,380 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000e.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000e.tmp saved
(131,917 real changes made, 131,917 to missing)
(142,892 real changes made, 142,892 to missing)
(146,948 real changes made, 146,948 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000f.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000f.tmp saved
(130,112 real changes made, 130,112 to missing)
(141,956 real changes made, 141,956 to missing)
(145,536 real changes made, 145,536 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000g.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000g.tmp saved
(112,204 real changes made, 112,204 to missing)
(123,853 real changes made, 123,853 to missing)
(126,797 real changes made, 126,797 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000h.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000h.tmp saved
(113,788 real changes made, 113,788 to missing)
(125,470 real changes made, 125,470 to missing)
(128,081 real changes made, 128,081 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000i.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000i.tmp saved
(114,024 real changes made, 114,024 to missing)
(126,079 real changes made, 126,079 to missing)
(127,966 real changes made, 127,966 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000j.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000j.tmp saved
(112,540 real changes made, 112,540 to missing)
(127,533 real changes made, 127,533 to missing)
(128,719 real changes made, 128,719 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000k.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000k.tmp saved
(112,639 real changes made, 112,639 to missing)
(129,117 real changes made, 129,117 to missing)
(130,193 real changes made, 130,193 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000l.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000l.tmp saved
(179,987 real changes made, 179,987 to missing)
(211,303 real changes made, 211,303 to missing)
(212,904 real changes made, 212,904 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000m.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000m.tmp saved
(175,756 real changes made, 175,756 to missing)
(209,812 real changes made, 209,812 to missing)
(211,766 real changes made, 211,766 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000n.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000n.tmp saved
(172,172 real changes made, 172,172 to missing)
(208,433 real changes made, 208,433 to missing)
(210,975 real changes made, 210,975 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000o.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000o.tmp saved
(167,435 real changes made, 167,435 to missing)
(204,586 real changes made, 204,586 to missing)
(208,018 real changes made, 208,018 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000p.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000p.tmp saved
(163,795 real changes made, 163,795 to missing)
(201,291 real changes made, 201,291 to missing)
(205,193 real changes made, 205,193 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000q.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000q.tmp saved
(160,633 real changes made, 160,633 to missing)
(198,907 real changes made, 198,907 to missing)
(203,108 real changes made, 203,108 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000r.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000r.tmp saved
(159,415 real changes made, 159,415 to missing)
(196,921 real changes made, 196,921 to missing)
(201,293 real changes made, 201,293 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000s.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000s.tmp saved
(159,278 real changes made, 159,278 to missing)
(196,717 real changes made, 196,717 to missing)
(200,933 real changes made, 200,933 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000t.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000t.tmp saved
(158,742 real changes made, 158,742 to missing)
(197,385 real changes made, 197,385 to missing)
(202,379 real changes made, 202,379 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000u.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000u.tmp saved
(157,481 real changes made, 157,481 to missing)
(196,800 real changes made, 196,800 to missing)
(204,042 real changes made, 204,042 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000v.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000v.tmp saved
(152,608 real changes made, 152,608 to missing)
(190,072 real changes made, 190,072 to missing)
(199,127 real changes made, 199,127 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000w.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000w.tmp saved
(148,019 real changes made, 148,019 to missing)
(185,750 real changes made, 185,750 to missing)
(195,437 real changes made, 195,437 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_0000000x.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_0000000x.tmp saved
(147,598 real changes made, 147,598 to missing)
(186,285 real changes made, 186,285 to missing)
(196,884 real changes made, 196,884 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000010.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000010.tmp saved
(100,504 real changes made, 100,504 to missing)
(127,914 real changes made, 127,914 to missing)
(135,404 real changes made, 135,404 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000011.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000011.tmp saved
(141,617 real changes made, 141,617 to missing)
(182,854 real changes made, 182,854 to missing)
(193,398 real changes made, 193,398 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000012.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000012.tmp saved
(125,833 real changes made, 125,833 to missing)
(170,353 real changes made, 170,353 to missing)
(180,143 real changes made, 180,143 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000013.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000013.tmp saved
(124,063 real changes made, 124,063 to missing)
(171,295 real changes made, 171,295 to missing)
(180,510 real changes made, 180,510 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000014.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000014.tmp saved
(120,889 real changes made, 120,889 to missing)
(166,835 real changes made, 166,835 to missing)
(174,969 real changes made, 174,969 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000015.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000015.tmp saved
(120,695 real changes made, 120,695 to missing)
(167,375 real changes made, 167,375 to missing)
(174,922 real changes made, 174,922 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000016.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000016.tmp saved
(108,564 real changes made, 108,564 to missing)
(148,010 real changes made, 148,010 to missing)
(153,606 real changes made, 153,606 to missing)
(0 real changes made)
(note: file C:\Users\bilalh\AppData\Local\Temp\ST_00000017.tmp not found)
file C:\Users\bilalh\AppData\Local\Temp\ST_00000017.tmp saved

. 
. clear

. 
. // Combine the temporary files and output as a csv.
. foreach year of numlist $cps_start_year / $cps_end_year {
  2.   append using `summary_`year''
  3. }

. 
. format *mean *median %8.2f

. format *total* %13.0f

. 
. #delimit ;
delimiter now ;
. outsheet cps_year
>          mcaid_mean
>          mcaid_median
>          mcaid_total_recipients
>          mcaid_total_dollars
>          snap_mean
>          snap_median
>          snap_total_recipients
>          snap_total_dollars
>          ssi_mean
>          ssi_median
>          ssi_total_recipients
>          ssi_total_dollars
>          housing_assist_mean
>          housing_assist_median
>          housing_assist_total_recipients
>          housing_assist_total_dollars
> 
> using $output_diagnostics_path\summary_statistics.csv, comma replace;

. #delimit cr
delimiter now cr
. 
end of do-file

. 
. 
. log close
      name:  <unnamed>
       log:  C:\data\sandboxes\means_tested_transfer_imputations\source_code\..\outputs\diagnostics\impute_means_te
> sted_transfers_log.txt
  log type:  text
 closed on:  26 Oct 2021, 13:59:44
-------------------------------------------------------------------------------------------------------------------
